## 第二章 信息的表示和处理

- **无符号编码** unsigned：表示大于或等于0的数字

- **补码编码** two‘s-complement： 表示有符号整数，正或负的数字

- **浮点数** floating-point: 表示实数的科学计数法，2为基数

  溢出 overflow、

  大量计算机的安全漏洞都是由计算机算术运算的微妙细节引发。

### 2.1 信息的存储

> 空间定义

定义信息表示的元空间大小，在此基础上进行编号，给计算机执行层使用。屏蔽硬件和实现差异，为程序执行提供统一的视角，字节数组。

**字节** Byte：从寻址角度，可寻址最小内存单元，8位的块

**虚拟内存** Virtual memory： 从程序视角，把内存当做一个非常大的字节数组

**地址 ** address：内存中每个字节的数字标识

**虚拟地址空间** Virtual address space：概念上的映像，所有可用地址的集合

> 空间划分

按功能需要，存放不同的程序对象。成熟数据、指令、控制信息。
程序对象，可以看做一个字节块
程序本身，就是一个字节序列

#### 2.1.1  十六进制表示

hexadecimal 

> 一个字节

**二进制表示**：0000 0000 ~ 1111 1111
**十进制表示**：0 ~ 255
**十六进制表示**：00 ~ FF

#### 2.1.2 字数据大小

计算机对空间的访问能力。64位机器向后兼容，可运行32位机器编译的程序

**字长** word size：字长决定系统能够表示的空间概念大小 0 ~ 2 ^ w -1

**32位/64位程序**：区别在程序是如何编译的。
C语言为避免机器和编译器设置的不同，定义了固定数据类型 int32_t (4字节)  int64_t (8字节)

程序应当具备在不同的机器和编译器上具有可移植性。

#### 2.1.3 寻址和字节顺序

程序对象可能跨越多个字节。对象的地址是什么？对象在内存中的字节如何排列。选择大端还是小端，没有技术上的理由。仅仅是一种表示而已

**对象地址**：所用字节中，最小的字节地址。
**小/大端法**：机器选择在内存中从要表示数字的**最低位/最高位**开始存放
大多数Intel兼容机都只用小端模式，IBM、Oracle使用Intel处理器。Android和ios也采用小端模式
比较新的未处理器采用双端法Bi-endian, 可配置。

大小端，对程序员是不可见的。

> 字节顺序可能存在的问题

1. 在不同类型的机器之间通过网络传送二进制数据。小端机器产生的数据送到大端机器上解析。
2. 阅读表示整数数据的字节序列时
3. C语言中，可以通过强制类型转换Cast或联合Union 

不同的机器/操作系统配置使用不同的存储分配规则。即指针地址的表示规则。

#### 2.1.4 表示字符串

C语言中，字符串被编码为字符数组。每个字符都有特定标准编码来表示，常见的是ASCII字符码。文本数据比二进制数据具有更强的平台独立性。

ASCII 适合编码英文。统一字符集 Unicode标准字库包括100 000个字符，使用32位表示一个字符。
UTF-8, 将每个字符编码为一个字节序列。
JAVA 使用Unicode来表示字符串。

#### 2.1.5 表示代码

#### 2.1.6 布尔代数简介

#### 2.1.7 C语言中的位级运算

#### 2.1.8 C语言中的逻辑运算

#### 2.1.9 C语言中的移位运算

### 2.2 整数表示

#### 2.2.1 整型数据类型

#### 2.2.2 无符号数的编码

#### 2.2.3 补码编码

#### 2.2.4 有符号数和无符号数之间的转换

#### 2.2.5 C语言中的有符号数和无符号数

#### 2.2.6 扩展一个数字的位表示

#### 2.2.7 截断数字

#### 2.2.8 关于有符号数与无符号数的建议

### 2.3 整数运算

#### 2.3.1 无符号加法

#### 2.3.2 补码加法

#### 2.3.3 补码的非

#### 2.3.4 无符号的乘法

#### 2.3.5 补码乘法

#### 2.3.6 乘以常数

#### 2.3.7 除以2的幂

#### 2.3.8 关于整数运算的最后思考

### 2.4 浮点数

#### 2.4.1 二进制小数

#### 2.4.2 IEEE浮点表示

#### 2.4.3 数字示例

#### 2.4.4 舍入

#### 2.4.5 浮点运算

#### 2.4.6 C语言中的浮点数

### 2.5 小结



