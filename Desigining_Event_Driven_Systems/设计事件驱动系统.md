# 事件驱动系统设计

基于Apache Kafka的流服务概念和模式 (Ben Stopford)

![coverpage](E:\GIT_new\Desigining_Event_Driven_Systems\coverpage.png) 

## 前言

## 序言

------

## 第一部分：引论

### 1. 概述

长久以来，我们讨论服务，其实是在讨论数据。事实上，在“微服务”一词出现以前，回想传统的面向服务的架构，我们是这样讨论数据：如何访问，数据在哪，谁拥有它。尤其在保证我们的业务持续成功中，数据是至关重要的，但是在系统设计和演进中，也被认为是一项巨大的约束。

我的个人关于在微服务中的工作经历，设计帮助组织更快的传送软件。这意味着有很长的时间花费在类似周期时间的分析，pipeline构建的设计，自动化测试，自动化的基础设施。云的到来对我们的工作带来了巨大的机遇，因为改进的自动化使我们更有生产力。但我一直遇到一些基本问题。太频繁了，软件并没有设计成更容易被传送的形式。同时数据成为问题的中心。

当时，在基于服务的系统中，多服务间共享数据库是最常用的模式。理由很简单，需要的数据已经在这个数据库中，而且访问一个数据库很简单，因此只需要抵达数据库并获取需要的数据。在新服务的快速开发中，这么做可能是允许的，但是时间一长，这将变成巨大的约束。

正如我在《构建微服务》一书中描述的那样，一个共享的数据库会在架构中产生一个巨大的耦合点。在多服务中该如何更改共享的Schema变得很难理解。David Parnas 早在1971年就指出，使一个软件中部分独立可变的秘密，是在模块间隐藏信息。但是，在把一个Schema暴露到多个服务中，阻止了我们独立演进代码库的能力。（D. L. Parnas，*关于将系统分解为模块的准则*  On the Criteria to Be Used in Decomposing Systems into Modules (Pittsburgh, PA: Carnegie Mellon University, 1971）

### 2.  流的起源

### 3. Kafka是你想象中的样子吗？

#### 	Kafka像REST但却是异步的

#### 	Kafka像一个服务总线

#### 	Kafka像一个数据库

#### 	Kafka究竟是什么？—— 一个流平台

### 4. 不止是消息：Kafka Broker概述

#### 	日志：消息保存和分发的高效结构

#### 	线性扩展能力

#### 	多服务生态系统中的负载隔离

#### 	维持健壮的有序保障

#### 	确保消息持久性

#### 	服务的负载均衡和高可用

#### 	主题压缩(Compacted Topics)

#### 	长期数据存储

#### 	安全

#### 	小结

------

## 第二部分：设计事件驱动系统

### 5. 事件：协作的基础

#### 	命令、事件、请求

#### 	耦合和消息代理

#### 	使用事件进行通知

#### 	使用事件提供状态变化

#### 	使用哪种方式

#### 	事件协作模式

#### 	流处理间关系

#### 	请求和事件驱动协议混合

#### 	小结

### 6. 用状态函数处理事件

#### 	使服务有状态

#### 	小结

### 7.  事件溯源，CQRS，其他状态模式

（Command Query Responsibility Segregation 就是通常所说的读写隔离）

#### 	事件溯源、命令溯源、CQRS

#### 	数据的版本控制

#### 	让事件源于事实

#### 	命名查询职责分离

#### 	物化视图

#### 	多语言视图

#### 	全部事实或偏差？

#### 	用Kafka实现事件溯源和CQRS(命令查询职责分离)

#### 	小结

------

## 第三部分  重思企业级架构

### 8. 数据和服务的跨域共享

#### 	封装并不总是友好的

#### 	数据二分法

#### 	系统演变时发生了什么？

#### 	让外部数据成为一等公民

#### 	不要害怕演变

#### 	小结

### 9. 事件流作为共享的源事实

#### 	颠倒的数据库

#### 	小结

### 10. 精益数据

#### 	如果消息能记录，数据库就没必要记录

#### 	只取需要的数据，仅此而已

#### 	重建事件溯源视图

#### 	自动化和Schema迁移

#### 	小结

------

## 第四部分 一致性，并发，和演进

### 11. 事件驱动系统中的一致性和并发

#### 	事件的一致性

#### 	单独写原则

#### 	事务的原子化

#### 	标识和并发控制

#### 	局限性

#### 	小结

### 12. 事务，不是我们已知的那样

#### 	重复问题

#### 	使用事务API去除重复

#### 一次性完成幂等和原子提交

#### Kafka底层事务机制

#### 状态存储和事件发送的原子化

#### 是否需要事务？能否用幂等实现？

#### 哪些是事务不能处理的？

#### 在服务中利用事务

#### 小结

------

### 13. Schemas和数据随着时间的演变

#### 使用Schemas及时管理数据演变

#### 处理Schema变化和向后兼容

#### 在Schema变化中协作

#### 处理不可读消息

#### 删除数据

#### 区分公共和私有主题

#### 小结

------

## 第五部分 用Kafka实现流服务

### 14.Kafka流和KSQL

#### 用Kafka流和KSQL构建简单邮件服务

#### 窗口、合并、表和状态存储

#### 小结

### 15. 构建流式服务

#### 订单验证系统

#### 合并-过滤-处理

#### Kafka流中的事件溯源视图

#### 一个阻塞读使CQRS崩溃

#### 并发操作在流系统中的扩展

#### 合并的密钥更新

#### 重新分区和阶段执行

#### 等待N事件

#### 设计的体现

#### 一个更完整的流系统

#### 小结























