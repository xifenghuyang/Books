# 事件驱动系统设计

基于Apache Kafka的流服务概念和模式 (Ben Stopford)

![coverpage](.\coverpage.png) 

## 前言

## 序言

------

## 第一部分：引论

### 1. 概述

长久以来，我们讨论服务，其实是在讨论数据。事实上，在“微服务”一词出现以前，回想传统的面向服务的架构，我们是这样讨论数据：如何访问，数据在哪，谁拥有它。尤其在保证我们的业务持续成功中，数据是至关重要的，但是在系统设计和演进中，也被认为是一项巨大的约束。

我的个人关于在微服务中的工作经历，设计帮助组织更快的传送软件。这意味着有很长的时间花费在类似周期时间的分析，pipeline构建的设计，自动化测试，自动化的基础设施。云的到来对我们的工作带来了巨大的机遇，因为改进的自动化使我们更有生产力。但我一直遇到一些基本问题。太频繁了，软件并没有设计成更容易被传送的形式。同时数据成为问题的中心。

当时，在基于服务的系统中，多服务间共享数据库是最常用的模式。理由很简单，需要的数据已经在这个数据库中，而且访问一个数据库很简单，因此只需要抵达数据库并获取需要的数据。在新服务的快速开发中，这么做可能是允许的，但是时间一长，这将变成巨大的约束。

正如我在《构建微服务》一书中描述的那样，一个共享的数据库会在架构中产生一个巨大的耦合点。在多服务中该如何更改共享的Schema变得很难理解。David Parnas 早在1971年就指出，使一个软件中部分独立可变的秘密，是在模块间隐藏信息。但是，在把一个Schema暴露到多个服务中，阻止了我们独立演进代码库的能力。（D. L. Parnas，*关于将系统分解为模块的准则*  On the Criteria to Be Used in Decomposing Systems into Modules (Pittsburgh, PA: Carnegie Mellon University, 1971）

随着对软件变化的期望和需求，IT组织也发生着变化。从孤立的IT到面向业务和产品对齐的团队，这种转变帮助提升团队的客户关注度。这种转变常常发生在提升团队自治的行动中，允许他们提出新的想法，并且实现，最终交付，这些降低了团队同组织其他部分协作的需要。但是，高度耦合的架构，会在系统和运维团队间产生更重的协作，这些成为所有想实现优化自治的组织的敌人。

Amazon许多年前就关注这些。希望能够提升团队自治，从而让公司更快的开发和交付软件。为此，Amazon组建了小的、独立的团队，他们能够拥有整个交付的生命周期。Steve Yegge, 离开亚马逊前往谷歌，希望去探寻是什么让团队在臭名昭著的(某些圈子中认为的)“*杂乱平台(Platform Rant)*”中工作的如此出色。在这里，他概述了亚马逊首席执行官 Jeff Bezos 关于团队应该如何协作，以及该如何设计系统。这些观点，让我深有同感：

1. 所有团队今后都将通过服务的接口暴露他们的数据和功能。
2. 团队必须通过接口彼此间通信。
3. 不允许任何其他形式的进程间通信：禁止直接链接，禁止直接读另一个团队的数据库，禁止内存共享模型，禁止所有后门。唯一允许的通信方式是，通过网络进行服务接口的调用。

在我看来，我开始意识到，如何存储和共享数据是确保我们实现松耦合架构的关键。由于要用来隐藏信息，因此良好定义的接口是关键。如果我们需要在数据库中存储数据，这个数据库应该是服务的组成部分，并且不应该被其他服务直接访问。一个定义良好的接口应该能够指导，何时以及如何访问和操作数据。

我过去的几年大部分的时间，都被用来推广这些理念。随着人们逐渐接受这些，但挑战依然存在。事实上，服务确实需要协同工作，并且共享数据来完成一些事情。该如何更高效？该如何确保这些服务在系统的延迟和负载条件下，以一种和谐的方式完成？当一个服务需要从另一个服务获取大量的信息时会发生什么？

利用事件流，尤其是流相关的技术，比如Kafka，让这些成为可能。我们已经在使用消息代理来交换事件，但Kafka让事件流持久化这种能力，允许我们思考一种新的存储和交换数据的方式，让我们在松耦合自治架构的构建中不丢失数据。这本书中，Ben讨论了“把数据库从内部反过来”这个理念 —— 

### 2.  流的起源

### 3. Kafka是你想象中的样子吗？

#### 	Kafka像REST但却是异步的

#### 	Kafka像一个服务总线

#### 	Kafka像一个数据库

#### 	Kafka究竟是什么？—— 一个流平台

### 4. 不止是消息：Kafka Broker概述

#### 	日志：消息保存和分发的高效结构

#### 	线性扩展能力

#### 	多服务生态系统中的负载隔离

#### 	维持健壮的有序保障

#### 	确保消息持久性

#### 	服务的负载均衡和高可用

#### 	主题压缩(Compacted Topics)

#### 	长期数据存储

#### 	安全

#### 	小结

------

## 第二部分：设计事件驱动系统

### 5. 事件：协作的基础

#### 	命令、事件、请求

#### 	耦合和消息代理

#### 	使用事件进行通知

#### 	使用事件提供状态变化

#### 	使用哪种方式

#### 	事件协作模式

#### 	流处理间关系

#### 	请求和事件驱动协议混合

#### 	小结

### 6. 用状态函数处理事件

#### 	使服务有状态

#### 	小结

### 7.  事件溯源，CQRS，其他状态模式

（Command Query Responsibility Segregation 就是通常所说的读写隔离）

#### 	事件溯源、命令溯源、CQRS

#### 	数据的版本控制

#### 	让事件源于事实

#### 	命名查询职责分离

#### 	物化视图

#### 	多语言视图

#### 	全部事实或偏差？

#### 	用Kafka实现事件溯源和CQRS(命令查询职责分离)

#### 	小结

------

## 第三部分  重思企业级架构

### 8. 数据和服务的跨域共享

#### 	封装并不总是友好的

#### 	数据二分法

#### 	系统演变时发生了什么？

#### 	让外部数据成为一等公民

#### 	不要害怕演变

#### 	小结

### 9. 事件流作为共享的源事实

#### 	颠倒的数据库

#### 	小结

### 10. 精益数据

#### 	如果消息能记录，数据库就没必要记录

#### 	只取需要的数据，仅此而已

#### 	重建事件溯源视图

#### 	自动化和Schema迁移

#### 	小结

------

## 第四部分 一致性，并发，和演进

### 11. 事件驱动系统中的一致性和并发

#### 	事件的一致性

#### 	单独写原则

#### 	事务的原子化

#### 	标识和并发控制

#### 	局限性

#### 	小结

### 12. 事务，不是我们已知的那样

#### 	重复问题

#### 	使用事务API去除重复

#### 一次性完成幂等和原子提交

#### Kafka底层事务机制

#### 状态存储和事件发送的原子化

#### 是否需要事务？能否用幂等实现？

#### 哪些是事务不能处理的？

#### 在服务中利用事务

#### 小结

------

### 13. Schemas和数据随着时间的演变

#### 使用Schemas及时管理数据演变

#### 处理Schema变化和向后兼容

#### 在Schema变化中协作

#### 处理不可读消息

#### 删除数据

#### 区分公共和私有主题

#### 小结

------

## 第五部分 用Kafka实现流服务

### 14.Kafka流和KSQL

#### 用Kafka流和KSQL构建简单邮件服务

#### 窗口、合并、表和状态存储

#### 小结

### 15. 构建流式服务

#### 订单验证系统

#### 合并-过滤-处理

#### Kafka流中的事件溯源视图

#### 一个阻塞读使CQRS崩溃

#### 并发操作在流系统中的扩展

#### 合并的密钥更新

#### 重新分区和阶段执行

#### 等待N事件

#### 设计的体现

#### 一个更完整的流系统

#### 小结























