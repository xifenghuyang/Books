# 事件驱动系统设计

基于Apache Kafka的流服务概念和模式 (Ben Stopford)

![coverpage](.\coverpage.png) 

## 序言

长久以来，我们讨论服务，其实是在讨论数据。事实上，在“微服务”一词出现以前，回想传统的面向服务的架构，我们是这样讨论数据：如何访问，数据在哪，谁拥有它。尤其在保证我们的业务持续成功中，数据是至关重要的，但是在系统设计和演进中，也被认为是一项巨大的约束。

我的个人关于在微服务中的工作经历，设计帮助组织更快的传送软件。这意味着有很长的时间花费在类似周期时间的分析，pipeline构建的设计，自动化测试，自动化的基础设施。云的到来对我们的工作带来了巨大的机遇，因为改进的自动化使我们更有生产力。但我一直遇到一些基本问题。太频繁了，软件并没有设计成更容易被传送的形式。同时数据成为问题的中心。

当时，在基于服务的系统中，多服务间共享数据库是最常用的模式。理由很简单，需要的数据已经在这个数据库中，而且访问一个数据库很简单，因此只需要抵达数据库并获取需要的数据。在新服务的快速开发中，这么做可能是允许的，但是时间一长，这将变成巨大的约束。

正如我在《构建微服务》一书中描述的那样，一个共享的数据库会在架构中产生一个巨大的耦合点。在多服务中该如何更改共享的Schema变得很难理解。David Parnas 早在1971年就指出，使一个软件中部分独立可变的秘密，是在模块间隐藏信息。但是，在把一个Schema暴露到多个服务中，阻止了我们独立演进代码库的能力。（D. L. Parnas，*关于将系统分解为模块的准则*  On the Criteria to Be Used in Decomposing Systems into Modules (Pittsburgh, PA: Carnegie Mellon University, 1971）

随着对软件变化的期望和需求，IT组织也发生着变化。从孤立的IT到面向业务和产品对齐的团队，这种转变帮助提升团队的客户关注度。这种转变常常发生在提升团队自治的行动中，允许他们提出新的想法，并且实现，最终交付，这些降低了团队同组织其他部分协作的需要。但是，高度耦合的架构，会在系统和运维团队间产生更重的协作，这些成为所有想实现优化自治的组织的敌人。

Amazon许多年前就关注这些。希望能够提升团队自治，从而让公司更快的开发和交付软件。为此，Amazon组建了小的、独立的团队，他们能够拥有整个交付的生命周期。Steve Yegge, 离开亚马逊前往谷歌，希望去探寻是什么让团队在臭名昭著的(某些圈子中认为的)“*杂乱平台(Platform Rant)*”中工作的如此出色。在这里，他概述了亚马逊首席执行官 Jeff Bezos 关于团队应该如何协作，以及该如何设计系统。这些观点，让我深有同感：

1. 所有团队今后都将通过服务的接口暴露他们的数据和功能。
2. 团队必须通过接口彼此间通信。
3. 不允许任何其他形式的进程间通信：禁止直接链接，禁止直接读另一个团队的数据库，禁止内存共享模型，禁止所有后门。唯一允许的通信方式是，通过网络进行服务接口的调用。

在我看来，我开始意识到，如何存储和共享数据是确保我们实现松耦合架构的关键。由于要用来隐藏信息，因此良好定义的接口是关键。如果我们需要在数据库中存储数据，这个数据库应该是服务的组成部分，并且不应该被其他服务直接访问。一个定义良好的接口应该能够指导，何时以及如何访问和操作数据。

我过去的几年大部分的时间，都被用来推广这些理念。随着人们逐渐接受这些，但挑战依然存在。事实上，服务确实需要协同工作，并且共享数据来完成一些事情。该如何更高效？该如何确保这些服务在系统的延迟和负载条件下，以一种和谐的方式完成？当一个服务需要从另一个服务获取大量的信息时会发生什么？

利用事件流，尤其是流相关的技术，比如Kafka，让这些成为可能。我们已经在使用消息代理来交换事件，但Kafka让事件流持久化这种能力，允许我们思考一种新的存储和交换数据的方式，让我们在松耦合自治架构的构建中不丢失数据。这本书中，Ben讨论了“把数据库从内部反过来”这个理念 —— 我猜测这个概念将得到更多的怀疑回应，就像我之前建议的离开巨型共享数据库一样。但是在最近2年，我和Ben探讨这些理念，我不禁思考，他和其他人在这些概念下工作，技术(这里一定有很多现有技术) 确实在做某些事情。

我希望这本书中描述的概念从另一个方面去引导我们思考关于数据共享和交互，帮助改变如何构建微服务架构。这些想法可能初看起来有些奇怪，请坚持下来。Ben将带你开启一段有趣的旅程。

—— Sam Newman

## 前言

2006年，我在英国ThoughtWorks工作。办公室充满活力，有很多有趣的事情在进行。敏捷行动兴盛，BDD(行为驱动开发)正浓，人们正经历Event Sourcing事件溯源，SOA(面向服务架构)被适用于更小的工程，处理在更大实现中遇到过的问题。

我所在的其中一项工作由Dave Farley领导，他是一个充满活力并且乐观的人，设法将他的乐观鼓舞传递到我们做的每一件事情中。这个项目是一个相对标准，中型大小的企业应用。有一个web站点，客户可以请求各种转让服务。系统将调用各种同步和异步进程，去执行无数的服务请求。

在那部分项目中，有大量有趣的元素，但其中一个困扰我的是服务间通信的方式。这是我工作的第一个由事件协作来独立构建的系统。有了之前一些基于服务的不同系统的工作经验，他们都是用RPC(远程过程调用)或者请求-响应消息构建，我认为这次的系统是不一样的。有一些固有的方式，添加新服务到事件流中，以及高度满足的事件日志记录和对系统过去叙述的观察。

几年后，我在一个大型金融机构工作，我想在公司中心构建一个数据服务，在这上面，应用可以查看使银行工作的重要数据集，交易，评估，参考数据等。我发现这类问题十分引人注目：尽管很多银行和一些大型公司以前曾采取过这种方法，依然具有技术挑战性，就好像技术到达了这个点——我们可以构建出非常有趣且具有变革性的东西。然而，正确使用技术只是问题的开始。这个系统需要和每个主要部分交互，这就意味着许多项目利益相关的人，有大量的请求，大量不同的发布时间表，大量正常运行时间的期望。我记得，我们和利益相关人在为期2周的项目启动会上讨论了项目的实用性。这似乎是一个很高的要求，不仅在技术上，而且在组织上。但这看起来似乎很合理。

因此，我们拉起了一个团队，一批来自ThoughtWorks和谷歌以及其他地方的人，最终的系统有一些非常有趣的属性。数据存储区将可查询的数据保存爱内存中，在每个数据中心分发给超过35台计算机，因此它可以处理来自计算网格的命中。写操作直接通过请求层到达消息系统，形成了(当时有些不寻常的)记录系统。请求层和消息层都被设计为共享的，因此他们可以线性扩展。所以每个插入或更新也是一个事件发布，并且也没有回避事件发布；它被镌刻到架构的核心中。

使消息传递成为记录系统的有趣之处在于，你发现自己重新利用数据流来做各种有用的事情：在文件系统中记录事件用来恢复，把它推向其他数据中心，使一组数据库变得充实用来报告和分析，当然，广播到任何一个想监听这个API的设备。

但是，当时我忽略了使用消息作为系统记录的真正的重要性。我记得在QCon大会上关于这个项目的演讲，有很多关于“消息传递作为系统记录”这张幻灯片的问题，超出了讨论所关注的精美的分布式连接层，我在很大程度上掩饰了这些。因此，这些逐渐变得很明显，所有特征——数据驱动的预缓存使连接更快，文档上的SQL接口，不可变数据模型，和后期绑定的schema—— 大多数客户的需求只有细微的差别，并且相对更简单。尽管他们是从直接使用数据服务开始，随着时间，一些需求将经常导致他们去复制，并独立去存储，最终做他们自己的事。但是尽管如此，他们依然发现中央数据集很有用，通常会去一个子集，然后再返回取更多的。因此，经过考虑，比起用优化的数据库发布数据集，仿佛使用一个优化的消息传递系统来保存数据集更合适。不久之后便形成了Confluent，Kafka似乎是这类问题的完美解决方案。

这两个经历的有趣之处(传输应用和银行范围数据服务)是，他们比最初看起来联系更紧密。传输应用具有出色的协作性，并且使可插入的。在银行项目中，一个更大的应用和服务集通过事件整合在一起，但也利用了他们可以到达的历史参考和查询。因此，场景十分不同——前一个是单体应用，后一个是企业—— 但这两个系统的优雅之处都在于他们对事件的使用。

流系统如今在很多方面与上述两个例子大不相同，但是底层模式并没有真正改变太多。

------

## 第一部分：引论

### 1. 序言

### 2.  流的起源

### 3. Kafka是你想象中的样子吗？

#### 	Kafka像REST但却是异步的

#### 	Kafka像一个服务总线

#### 	Kafka像一个数据库

#### 	Kafka究竟是什么？—— 一个流平台

### 4. 不止是消息：Kafka Broker概述

#### 	日志：消息保存和分发的高效结构

#### 	线性扩展能力

#### 	多服务生态系统中的负载隔离

#### 	维持健壮的有序保障

#### 	确保消息持久性

#### 	服务的负载均衡和高可用

#### 	主题压缩(Compacted Topics)

#### 	长期数据存储

#### 	安全

#### 	小结

------

## 第二部分：设计事件驱动系统

### 5. 事件：协作的基础

#### 	命令、事件、请求

#### 	耦合和消息代理

#### 	使用事件进行通知

#### 	使用事件提供状态变化

#### 	使用哪种方式

#### 	事件协作模式

#### 	流处理间关系

#### 	请求和事件驱动协议混合

#### 	小结

### 6. 用状态函数处理事件

#### 	使服务有状态

#### 	小结

### 7.  事件溯源，CQRS，其他状态模式

（Command Query Responsibility Segregation 就是通常所说的读写隔离）

#### 	事件溯源、命令溯源、CQRS

#### 	数据的版本控制

#### 	让事件源于事实

#### 	命名查询职责分离

#### 	物化视图

#### 	多语言视图

#### 	全部事实或偏差？

#### 	用Kafka实现事件溯源和CQRS(命令查询职责分离)

#### 	小结

------

## 第三部分  重思企业级架构

### 8. 数据和服务的跨域共享

#### 	封装并不总是友好的

#### 	数据二分法

#### 	系统演变时发生了什么？

#### 	让外部数据成为一等公民

#### 	不要害怕演变

#### 	小结

### 9. 事件流作为共享的源事实

#### 	颠倒的数据库

#### 	小结

### 10. 精益数据

#### 	如果消息能记录，数据库就没必要记录

#### 	只取需要的数据，仅此而已

#### 	重建事件溯源视图

#### 	自动化和Schema迁移

#### 	小结

------

## 第四部分 一致性，并发，和演进

### 11. 事件驱动系统中的一致性和并发

#### 	事件的一致性

#### 	单独写原则

#### 	事务的原子化

#### 	标识和并发控制

#### 	局限性

#### 	小结

### 12. 事务，不是我们已知的那样

#### 	重复问题

#### 	使用事务API去除重复

#### 一次性完成幂等和原子提交

#### Kafka底层事务机制

#### 状态存储和事件发送的原子化

#### 是否需要事务？能否用幂等实现？

#### 哪些是事务不能处理的？

#### 在服务中利用事务

#### 小结

------

### 13. Schemas和数据随着时间的演变

#### 使用Schemas及时管理数据演变

#### 处理Schema变化和向后兼容

#### 在Schema变化中协作

#### 处理不可读消息

#### 删除数据

#### 区分公共和私有主题

#### 小结

------

## 第五部分 用Kafka实现流服务

### 14.Kafka流和KSQL

#### 用Kafka流和KSQL构建简单邮件服务

#### 窗口、合并、表和状态存储

#### 小结

### 15. 构建流式服务

#### 订单验证系统

#### 合并-过滤-处理

#### Kafka流中的事件溯源视图

#### 一个阻塞读使CQRS崩溃

#### 并发操作在流系统中的扩展

#### 合并的密钥更新

#### 重新分区和阶段执行

#### 等待N事件

#### 设计的体现

#### 一个更完整的流系统

#### 小结























